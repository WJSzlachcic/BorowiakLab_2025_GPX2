---
title: "Functions"
output: html_notebook
---


dittoBarPlot_norm
```{r}
#a function for plotting a dittoBarPlot with data normalized by cell number per group

#Arguments:
#SO - object variable of dittoBarPlot
#var - var variable of dittoBarPlot
#group.by - group.by variable of dittoBarPlot

dittoBarPlot_norm <- function(SO, var, group.by, var.labels.reorder = NULL, x.reorder = NULL) {
 ditt <- dittoSeq::dittoBarPlot(
    object = SO,
    var = var,
    group.by = group.by,
    data.out = TRUE, 
    var.labels.reorder = var.labels.reorder,
    x.reorder = x.reorder,
    main = "Genotype - not normalized")
plot1 <- ditt[1]
print(plot1)
#Extract and modify data.table - divide by proportion of cells within each genotype per all cells
Gntp_per_cluster_norm <- as.data.frame(ditt[2])
rm(ditt)
#for each genotype count normalization factor (ncells_genotype/ncells_all); retrieve ncells per genotype from
ncells_tbl <- as.data.frame(table(SO[[var]])) %>% mutate(total = ncol(SO))
colnames(ncells_tbl) <- c("data.label", "ncells", "total")
Gntp_per_cluster_norm <- Gntp_per_cluster_norm %>%
  left_join(ncells_tbl) %>%
  mutate(normalized.data.count = data.count*total/ncells) %>%
  group_by(data.grouping) %>%
  mutate(normalized.grouping.count = sum(normalized.data.count)) %>%
  ungroup() %>%
  mutate(normalized.data.percent = normalized.data.count/normalized.grouping.count) %>%
  select(data.label, data.grouping, normalized.data.percent)
#palette = dittoSeq::dittoColors()[1:5]
plot2 <- ggplot(Gntp_per_cluster_norm, aes(fill=data.label, y=normalized.data.percent, x=data.grouping)) +
    geom_bar(position="fill", stat="identity") + theme_classic() + scale_fill_hue(name = paste(var)) + labs(x = paste(group.by), y = "Percent of cells", title = paste(var, "- normalized"))
print(plot2)
return(list(plot1, plot2, Gntp_per_cluster_norm))
}
  
```

plot_top_DE
```{r}
#a function for plotting top genes from a DE analysis

#Arguments:
#SO - Seurat object, can be filtered using subset() function in the formula
#DEG - DEG table
#DEG.groups - column for which grouping
#top - how many genes per group
#sort.by - which column to sort by
#direction - direction of DEG regulation to be selected & plotted - can be "up", "down" or "both". "up" by default.
#group.by - Seurat meta.data to group by; takes Idents() if set to NUL
#scale -	Determine whether the data is scaled, TRUE for default
#deg.method - DEG method used to create DEG table, "delegate" by default, change to "findall" for Seurat's FindAllMArkers
#min, max/mid/min.color - from dittoSeq::dittoDotPlot
#cells.fraction - fraction of cells in both groups with detected expression of a gene 0.3 by default
#fc.thr, padj.thr - thresholds for log_fc (= 1 by default) and p_adj (=0.01 by default)
#type - type of input ("module", "term") from which DEGs are taken, if NULL input is considered as a gene

plot_top_DE <- function(SO, DEG, DEG.groups, top, sort.by, direction = "up", group.by, scale = TRUE, deg.method = "delegate", min = "make", fc.thr = 0.5, padj.thr = 0.05, cells.fraction = 0.3, type = NULL, term = NULL, assay = "SCT"){
    if(deg.method == "findall"){
    DEG <- DEG %>% dplyr::rename(padj = p_val_adj, log_fc = avg_log2FC, feature = gene, rate1 = pct.1, rate2 = pct.2)
  }
  top_m <- select_top_DE(DEG = DEG, DEG.groups = DEG.groups, top = top, cells.fraction = cells.fraction, sort.by = sort.by, direction = direction, fc.thr = fc.thr, padj.thr = padj.thr)
  
    #if single value only uses Seurat::DotPlot, otherwise uses dittoDotPlot
  if(length(top_m[[2]]) == 1) {top_plot <- DotPlot(SO, features = top_m[[2]], assay = assay, group.by = group.by, scale = scale) + RotatedAxis() + scale_colour_gradient2(low = "blue", mid = "grey95", high = "red") 
  }
  else {top_plot <- dittoSeq::dittoDotPlot(SO, vars = top_m[[2]], assay = assay, group.by = group.by, scale = scale, min.color = "blue", max.color = "red", mid.color = "grey90", min = min, summary.fxn.size = function(x) {100*mean(x != 0)} ) 
  
  #Plot title depending on input type
  if(is.null(type)){
    top_plot <- top_plot + ggtitle(paste("Top", top, "DEGs",  ifelse(direction == "both", "up and down", direction)))
  }
  else{
    if(type == "module"){
    top_plot <- top_plot + ggtitle(paste("Top", top, "DEGs",  ifelse(direction == "both", "up and down", direction), "from module", term))
  }
  
  if(type == "term"){
    top_plot <- top_plot + ggtitle(paste("Top", top, "DEGs",  ifelse(direction == "both", "up and down", direction), "from", term, "pathway"))
  }
  }
  
  return(list(top_m, top_plot))

}
```


pathways_heatmap
```{r}
#a function for plotting top features from pathway analysis (decoupleR/escape) data as a heatmap


#Arguments:
#SO - Seurat object to use
#assay - assay with stored pathway analysis to use, e.g. dR.PROGENY or dR.CollecTRI; default is NULL, which takes current DefaultAssay of the SO
#layer - which layer of the assay to use for analysis, default is "data"
#group.by - metadata by which to group.by, e.g. "seurat_clusters"
#subset - how is SO to be subsetted, use as with 'subset' option of the subset() function; deafult is NULL (= no subsetting)
#subset.gr - meta.data in which to search for the 'subset' values
#invert - as in the subset() function, by default = FALSE;
#DEG - DEG list; This list can be subsetted using subset() when specyfing DEG (this is separate from above within-function options: 'subset', 'subset.gr' amd 'invert' which allow to subset SO)
#DEG.groups - column for which grouping
#top - how many top regulons to plot per row (i.e. per group.by feature)
#label - name of database (for heatmap title), e.g. TF regulons
#scale - how data on the heatmap should be scaled, as in pheatmap function; options: "row", "column" and "none"; "column" by default
#cluster_rows - if rows should be clusters, 'FALSE' by default (so order is kept as in groups) 
#cluster_cols - if rows should be clustered, 'FALSE' by default (so order is based on top values per group) 
#rename - string to be removed from term names on a plot, e.g. for MSigDB Hallmark - "Hallmark-", NA by default
#sort.by - which column to sort by, either "padj" or "log_fc"
#direction - which direction of deregulation to show ('up', 'down', 'both'), 'up' by default
#cells.fraction - threshold for fraction of cells expressing a marker
#fc.thr, padj.thr - thresholds for DE to be plotted, defaults: fc.thr = 0.5, padj.thr = 0.05

pathways_heatmap <- function(SO, assay = NULL, layer = "data", group.by, subset = NULL, subset.gr = NULL, invert = FALSE, DEG, DEG.groups, top, label, sort.by = "padj", scale = "column", cluster_rows = FALSE, cluster_cols = FALSE, rename = NA, direction = "up", cells.fraction = 0.3, fc.thr = 0.2, padj.thr = 0.05, fontsize = 10) { 

  top_DE <- select_top_DE(DEG, DEG.groups, top, cells.fraction = cells.fraction, fc.thr = fc.thr, padj.thr = padj.thr, sort.by = sort.by, direction = direction)

  DefaultAssay(SO) <- assay
  if(!is.null(subset)){
    gb.subset.gr <- sym(subset.gr)
    SO <- subset(SO, subset = !!gb.subset.gr %in% subset, invert = invert)}
    
  
  mtx <- top_features_matrix(SO, layer, group.by , top_DE[[2]])

  if(!is.na(rename)){
    colnames(mtx) = gsub(rename,"", colnames(mtx))
  }
    
# Choose color palette
palette_length = 100
my_color = colorRampPalette(c("darkblue", "grey99","red"))(palette_length)

# Plot
plot <- pheatmap::pheatmap(mtx, scale = scale, border_color = NA, color=my_color, breaks = NA, cluster_rows = cluster_rows, cluster_cols = cluster_cols, main = ifelse(top == 0, paste(label), paste("Top", top, label, ifelse(direction == "both", paste("up and down"), paste(direction)))), fontsize = fontsize)

return(plot)
 
}
 
```


find_pseudotime_delta 

```{r}
#a function for finding differentially behaving genes/pathways/regulons/modules along two chosen pseudotime trajectories and plotting them. It can be also used to plot specific terms (set.y).  

#Arguments:
#SO - Seurat object
#set.type - type of features to be plotted; 'meta' for meta.data (e.g. modules), 'feat' for genes or rownames from other assays (e.g. decoupleR)
#trajectory - meta.data in which trajectory information is stored, "trajectory" by default; if NULL, then 
#incl.common - to choose if cells common for both trajectories should be used (FALSE by default) 
#assay - assay to be used - use "SCT" for genes and other for specific decoupleR term (e.g. dR.PROGENy); 'SCT' by default.
#meta.x - name of meta.data level plotted on x axis (e.g. pseudotime)
#set.y - names of single/multiple meta.data OR features plotted on y axis; will search for a string: for meta.data starting with set.y name, for features based on regex expression, e.g. "^ETV"; can use vector of characters (e.g. c("MAPK", "Hypoxia", "WNT")); 
#group1, group2 - names of trajectories you want to be plotted
#top - how many terms to plot (these are top by AUC difference if arrange = T; or in order given if arrange = F)
#arrange - if plots are to be arranged by AUC difference; TRUE by default
#filter.auc - to filter by absolute AUC values, FALSE by default; inserting number will filter so at least one trajectory has higher abs value than input

find_pseudotime_delta <- function(SO, trajectory = "trajectory", incl.common = F, set.type = "meta", assay = "RNA", meta.x = "pseudotime", set.y, group1, group2, top, arrange = TRUE, filter.auc = F){
  
  #pull names of trajectories
  
  if(rlang::is_false(incl.common)){
    names <- SO[[trajectory]] %>% 
      filter(trajectory != "not-in-trajectory") %>% 
      filter(trajectory != "common") %>% 
      arrange(trajectory) %>% 
      pull(trajectory) %>% 
      unique()
    print(names)
    }
  else{
      names <- SO[[trajectory]] %>% filter(trajectory != "not-in-trajectory") %>% arrange(trajectory) %>% pull(trajectory) %>% unique()
      print(names)
    }
    
  #subset SO to only cells within trajectories
  sym.tr <- sym(trajectory)
  sbst <- subset(SO, subset = !!sym.tr %in% names)

  ##prepare input - features to check
  trajectory.terms <- vector(mode='list', length=2)
  for(i in 1:2) {
   if(rlang::is_false(incl.common)) {
     SO.trajectory <- subset(sbst, subset = !!sym.tr == names[[i]])
   }
   else{
     SO.trajectory <- subset(sbst, subset = !!sym.tr %in% c(names[[1]], names[[i+1]]))
   }
   trajectory.terms[[i]] <- multi_terms_df(SO = SO.trajectory, set.type = set.type, assay = assay, meta.x = meta.x, set.y = set.y) %>% arrange(.[2]) #arrange necessary for AUC function
  }
  names(trajectory.terms)[1] <- group1
  names(trajectory.terms)[2] <- group2

  ## Calculate AUC (area under curve) and delta between groups for each term
  df.AUC <- table_auc(input = trajectory.terms)
  
  #filtering by absolute calculated AUC values
  if(!rlang::is_false(filter.auc)){
    df.AUC <- df.AUC %>% filter((abs(group1) >= filter.auc)|(abs(group2) >= filter.auc))
  }
  
  ##select top differential curves  
    if(rlang::is_true(arrange)){
  top.AUC <- df.AUC %>% arrange(-abs(delta)) %>% slice_head(n = top) %>% pull(1) 
  }
  else{top.AUC <- df.AUC %>% slice_head(n = top) %>% pull(1)}
  
  ##filter terms in trajectory.terms
  tbl.top <- trajectory.terms %>% 
    bind_rows(.id = "trajectory") %>%
    select(c(1:3, any_of(top.AUC))) 

  ##plot them
    #create list of plots
    ggList <- list()
    for (i in 4:length(tbl.top)){
    ggList[[i-3]] <- plot_cont_meta_cond(tbl.top, i, group1, group2) 
    }
    #return ggplot list
    if(length(tbl.top) < 6){ncol = length(tbl.top)-3 }
    if(length(tbl.top) > 5){ncol = 3 }
    plot_multi <- cowplot::plot_grid(plotlist=ggList, ncol = ncol)

 return(list(df.AUC, tbl.top, plot_multi))  
}
```


######
HELPER FUNCTIONS
######

select_top_DE

```{r}
#a helper function for sorting DEG table for top markers (upregulated, downregulated or both)

#Arguments:
#DEG - DEG list; this list can be subsetted using subset() 
#DEG.groups - column for which grouping
#top - how many top regulons to plot per row (i.e. per group.by feature)
#sort.by - which column to sort by, either "padj" or "log_fc"
#direction - which direction of deregulation to show ('up', 'down', 'both'), 'up' by default
#cells.fraction - threshold for fraction of cells expressing a marker
#fc.thr, padj.thr - thresholds for DE to be plotted, defaults: fc.thr = 0.5, padj.thr = 0.05

select_top_DE <- function(DEG, DEG.groups, top, cells.fraction = 0.3, sort.by, direction = "up", fc.thr = 0.5, padj.thr = 0.05){
  DEG <- DEG %>% mutate(dir = case_when(
    log_fc > 0 ~ "UP",
    log_fc < 0 ~ "DOWN"))
    #,
    #TRUE ~ NA_character_))
  library(rlang)
  gb.deg <- sym(DEG.groups)
  
  if(!(sort.by %in% c("padj", "log_fc"))){stop("Invalid 'sort.by' argument. Must be 'padj' or 'log_fc'.")}
  
  DEG <- DEG %>%
    filter((rate1 + rate2) > cells.fraction) %>%
    filter(abs(log_fc) >= fc.thr) %>%
    filter(padj <= padj.thr)
  
  if(sort.by == "log_fc"){
    top_markers <- DEG %>%
    group_by(!!gb.deg, dir) %>%
    mutate(rank = row_number(-abs(get(sort.by)))) %>%
    ungroup()
    }
  else{top_markers <- DEG %>%
    group_by(!!gb.deg, dir) %>%
    mutate(rank = row_number(get(sort.by))) %>%
    ungroup()
    }
  
  if(nrow(top_markers) <1){stop("No DEG genes found. Try releasing 'fc.thr', 'padj.thr' or 'cells.fraction' thresholds")}

  if((direction == "both") & (nrow(top_markers) < 2*top)){print("Notice less DEGs found than 'top' value. Try releasing 'fc.thr', 'padj.thr' or 'cells.fraction' thresholds")}
  if((direction != "both") & (nrow(top_markers) < top)){print("Notice less DEGs found than 'top' value. Try releasing 'fc.thr', 'padj.thr' or 'cells.fraction' thresholds")}
  
  top_markers <- top_markers %>%
    slice_min(order_by = rank, by = c(!!gb.deg, dir), n = 3*top) %>%
    distinct(feature, .keep_all = TRUE) %>%
    slice_min(order_by = rank, by = c(!!gb.deg, dir), n = top)
  
  ifelse(direction %in% c("up", "down", "both"),
  
  top_markers <- top_markers %>% filter(case_when(
    direction == "up" ~ dir == "UP",
    direction == "down" ~ dir == "DOWN",
    direction == "both" ~ dir %in% c("UP", "DOWN")) 
  ), stop("Invalid 'dir' argument. Must be 'up', 'down', or 'both'."))
  
  top_markers_names <- top_markers %>% pull(feature)

  return(list(top_markers, top_markers_names))
}
```


top_features_matrix
```{r}
#a helper function for extracting top features from an SO assay (genes or regulon/pathway assays created from decoupleR/escape analysis)

top_features_matrix <- function(SO, layer, group.by, top) { 
  library(rlang)
  gb.group <- sym(group.by)
  
  groups <- FetchData(SO, vars = group.by) %>% dplyr::rename(cluster = !!gb.group) %>% tibble::rownames_to_column (var = "id")
  
  mtx <- t(as.matrix(GetAssayData(object = SO, layer = layer))) %>%
  as.data.frame() %>%
  tibble::rownames_to_column (var = "id") %>%
  left_join(groups) %>%  
  tibble::column_to_rownames (var = "id") %>%
  tidyr::pivot_longer(cols = -cluster, names_to = "source", values_to = "score") %>%
  group_by(cluster, source) %>%
  dplyr::summarise(mean = mean(score)) %>% 
  filter(source %in% top) %>%
  tidyr::pivot_wider(id_cols = 'cluster', names_from = 'source',
              values_from = 'mean')
  
  mtx <-  mtx[,c("cluster",top)] %>%
  tibble::column_to_rownames('cluster') %>%
  as.matrix()

return(mtx)
}
```

multi_terms_df
```{r}
#a helper function for extracting features from SO for plotting

multi_terms_df <- function(SO, set.type, y.type = "cont", assay = "SCT", meta.x, set.y){
  DefaultAssay(object = SO) <- assay
  if(set.type == "feat") {
    #create vector of feature names found in SO
    lst0 <- rownames(SO)
    lst <- NULL
    for(i in 1:length(set.y)){
    lst <- lst %>% 
      append(lst0[grepl(paste0(set.y[i]), lst0)]) %>%
      unique()
    }
    #extract feature names from SO
   set.tbl <- FetchData(SO, vars = lst, layer = "data") %>% #always using data slot!!
            tibble::rownames_to_column()

  }
  if(set.type == "meta"){ 
    set.tbl0 <- SO[[]] 
    set.tbl <- set.tbl0 %>% 
          select(contains(set.y)) %>%
          tibble::rownames_to_column()
    if(length(set.y) > 1){
      for(i in 2:length(set.y)){
        set.tbl.i <- set.tbl0 %>% 
          select(contains(set.y[i])) %>%
          tibble::rownames_to_column()
        set.tbl <- set.tbl %>% left_join(set.tbl.i)
      }
    }
  }
  
  if(!(set.type %in% c("feat", "meta"))) {stop("Feature set type not recognized. Allowed options: 'features' - for genes, decoupleR, and 'meta' - for numeric meta.data")}
  
  tbl <- SO[[meta.x]] %>% 
  tibble::rownames_to_column() %>%
  left_join(set.tbl)
  
  #remove cells with Inf pseudotime - usually cells from different partitions
  if(meta.x %in% "pseudotime"){
    tbl <- tbl %>% filter(pseudotime != 'Inf')}
  
  return(tbl)
}
```

plot_cont_meta_cond
```{r}
#a helper function for plotting continous data split by conditions


plot_cont_meta_cond <- function(tbl.top,i,group1, group2){
  x <- sym(names(tbl.top)[3])
  y <- sym(names(tbl.top)[i])
  
     g1 <- filter(tbl.top, trajectory == group1)
     g2 <- filter(tbl.top, trajectory == group2)

    ggplot(data = tbl.top, aes(x = !!x, y = !!y, color = trajectory)) +
    geom_smooth(data = g1, method = "gam", formula = y ~ s(x, bs = "cs")) + 
    geom_smooth(data = g2, method = "gam", formula = y ~ s(x, bs = "cs")) + 
    theme_classic()
}
```

table_auc
```{r}
#a helper function for creating data table with AUC and delta-AUC for each term

table_auc <- function(input) {
   #empty table for storing data
    df <- data.table(term = character(), group1 = numeric(), group2 = numeric())
  #calculate AUC
    for(i in 3:length(input[[1]])){
      output <- calculate_auc(input, i)
      df <- rbind(df, output)
    }
    #calculate delta-AUC for each term
    df <- df %>% mutate(delta = group1 - group2)   
    return(df)
}
```

calculate_auc
```{r}
#a helper function to calculate AUC (area under curve) using trapezoidal method

   calculate_auc <- function(input, i){
     output <- data.table(term = character(), group1 = numeric(), group2 = numeric())
     output[[1, 1]] <- colnames(input[[1]][i])
     for(j in 1:2){
      n <- length(input[[j]][[i]])
      output[[1, j+1]] <- sum(diff(input[[j]][[2]]) * (input[[j]][[i]][-1] + input[[j]][[i]][-n]) / 2)
     }
     return(output)
   }

```
